// -*- mode: c++; fill-column: 80; c-basic-offset: 2; indent-tabs-mode: nil -*-
/*
    Copyright (c) 2012 Juan Jose Garcia Ripoll

    Tensor is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
    by the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Library General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <tensor/linalg.h>
#include <mps/itebd.h>

namespace mps {

  template<class Tensor>
  static const Tensor ensure_3_indices(const Tensor &G)
  {
    if (G.rank() == 3) {
      return G;
    } else if (G.rank() == 4) {
      tensor::index a, i,j, b;
      G.get_dimensions(&a,&i,&j,&b);
      return reshape(G, a,i*j,b);
    } else {
      std::cerr << "Tensor with wrong dimensions in iTEBD" << std::endl;
      abort();
      return Tensor();
    }
  }

  template<class Tensor>
  static void
  ortho_basis(const Tensor V, Tensor *X, Tensor *Xinv)
  {
    /*
     * We have a basis |b> such that
     *		V(b,b') = <b'|b>
     * We decompose v into its eigenvalues, so that
     *		v = R * diag(s) * R'
     * where R is a unitary matrix R' R = R R' = identity.
     * These matrices give us a new orthogonal basis. Given
     *		|b> = U(b,c) |c>
     * we obtain, given <c|c'>=delta(c,c')
     *		v(b,b') = U(b,c) * U*(b',c') <c|c'> = U * U'
     * so that U = R * sqrt(s)
     */
    Tensor R;
    Tensor s = abs(linalg::eig_sym(V, &R));
    s = sqrt(s);
    *X = scale(R, -1, s);
    *Xinv = scale(adjoint(R), 0, 1.0/s);
  }

  template<class Tensor>
  static void
  ortho_right(const Tensor &G, const Tensor &l, Tensor *X, Tensor *Xinv)
  {
    /*
     * 1) Build the transfer matrices
     *		R(a,a',b,b') = G(a,i,b)l(b) G*(a',i,b')l*(b')
     */
    tensor::index a, b;
    Tensor R = build_E_matrix(scale(ensure_3_indices<Tensor>(G), -1, l),
                              &a, &b);
    /*
     * 2) Search for the largest eigenvalue v(a,a') which
     *	  is also the orthogonality matrix of the basis
     *	  generated by P.
     *		v(a,a') = <a' | a>
     */
    Tensor v;
    linalg::eig_power_right(R, &v);
    v = reshape(v, b,b);
    v = (v + adjoint(v));
    ortho_basis<Tensor>(v, X, Xinv);
  }

  template<class Tensor>
  static void
  ortho_left(const Tensor &G, const Tensor &l, Tensor *Y, Tensor *Yinv)
  {
    /*
     * 1) Build the transfer matrices
     *		L(a,a',b,b') = l(a)G(a,i,b) l*(a')G*(a',i,b')
     */
    tensor::index a, b;
    Tensor L = build_E_matrix(scale(ensure_3_indices<Tensor>(G), 0, l),
                              &a, &b);
    /*
     * 2) Search for the largest eigenvalue v(a,a') which
     *	  is also the orthogonality matrix of the basis
     *	  generated by P.
     *		v(b,b') = <b' | b>
     */
    Tensor v;
    linalg::eig_power_left(L, &v);
    v = reshape(v, b,b);
    v = (v + adjoint(v));
    ortho_basis<Tensor>(v, Y, Yinv);
  }

  template<class Tensor>
  static void
  canonical_form(Tensor G, Tensor l, Tensor *pGout, Tensor *plout,
                 double tolerance, tensor::index max_dim)
  {
    Tensor X;		/* X(b,c) */
    Tensor Xinv;	/* Xinv(c,b) */
    ortho_right<Tensor>(G, l, &X, &Xinv);

    Tensor Y;		/* Y(a,d) */
    Tensor Yinv;	/* Yinv(d,a) */
    ortho_left<Tensor>(G, l, &Y, &Yinv);

    /* Y(a,d) G(a,i,b) X(b,c) -> G(d,i,c) */
    G = fold(Xinv, -1, fold(G, -1, Yinv, -1), 0);

    /* Y(a,d) l(a)delta(a,b) X(b,c) = aux(c,d) */
    Tensor aux = fold(Y, 0, scale(X, 0, l), 0);

    /* l(c,d) = U(c,x) l(x) V(x,d) */
    Tensor U, V;
    *plout = limited_svd(aux, &U, &V, tolerance, max_dim);
    /* V(x,d) G(d,i,c) U(c,x') -> G(x,i,x') */
    *pGout = fold(fold(V, -1, G, 0), -1, U, 0);
  }

  template<class Tensor>
  static void
  split_tensor(Tensor GAB, Tensor lAB, Tensor *pA, Tensor *plA, Tensor *pB,
               Tensor *plB, double tolerance, tensor::index max_dim)
  {
    tensor::index a, i, j, b;
    /*
     * GAB is a coarse grain tensor that spans two sites. lB are the Schmidt
     * coefficients associated to this tensor. We first find the canonical form
     * so that the left and right basis are orthogonalized.
     */
    GAB.get_dimensions(&a,&i,&j,&b);
    canonical_form<Tensor>(reshape(GAB, a,i*j,b), lAB, &GAB, &lAB, tolerance, max_dim);
    a = b = lAB.size();
    /*
     * Now the state is given by
     *		|psi> = lB(a) GAB(a,i,j,b) lB(b) |a>|i,j>|b>
     * where |a> and |b> are orthonormal basis. We thus combine
     *		lB GAB lB -> GAB
     */
    GAB = scale(GAB, 0, lAB);
    GAB = scale(GAB, -1, lAB);
    /*
     * ...and perform the Schmidt decomposition of this tensor to obtain
     * the optimal "A" and "B".
     */
    *plB = lAB;
    *plA = Tensor(limited_svd(reshape(GAB, a*i, j*b), pA, pB, tolerance, max_dim));
    *pA = reshape(*pA, a, i, plA->size());
    *pB = reshape(*pB, plA->size(), i, b);
    *pA = scale(*pA, 0, 1.0/(*plB));
    *pB = scale(*pB, -1, 1.0/(*plB));
  }

  template<class Tensor>
  iTEBD<Tensor>::iTEBD(const Tensor &AB, const Tensor &lAB, double tolerance, tensor::index max_dim)
  : canonical_(true)
  {
    split_tensor<Tensor>(AB, lAB, &A_, &lA_, &B_, &lB_, tolerance, max_dim);
    AlA_ = scale(A_, -1, lA_);
    BlB_ = scale(B_, -1, lB_);
  }

  template<class Tensor>
  const iTEBD<Tensor>
  iTEBD<Tensor>::canonical_form() const
  {
    return iTEBD<Tensor>(fold(AlA_, -1, B_, 0), lB_, 0, 0);
  }

  template<class Tensor>
  const iTEBD<Tensor>
  iTEBD<Tensor>::apply_operator(const Tensor &U, int site, double tolerance,
                                tensor::index max_dim) const
  {
    tensor::index a, i, j, b;
    Tensor GAB = (site & 1) ? fold(BlB_, -1, A_, 0) : fold(AlA_, -1, B_, 0);
    const Tensor &lAB = (site & 1) ? lA_ : lB_;
    GAB.get_dimensions(&a, &i, &j, &b);
    GAB = reshape(foldin(U, -1, reshape(GAB, a, i*j, b), 1), a, i, j, b);
    return iTEBD<Tensor>(GAB, lAB, tolerance, max_dim);
  }

}
